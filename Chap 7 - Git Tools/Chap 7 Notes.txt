Git is smart enough to figure out what commit you’re referring to
 if you provide the first few characters of the SHA-1 hash
*at least 4 characters

$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

In this case, say you’re interested in the commit whose hash begins with 1c002dd.... 
You can inspect that commit with any of the following variations of git show
 (assuming the shorter versions are unambiguous):

$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d

rev-parse exists for lower-level operations and isn’t designed to be used in day-to-day operations

Here you can run rev-parse on your branch.
$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949

to see where your master branch was yesterday, you can type
$ git show master@{yesterday}
That would show you where tip of your master branch was yesterday.

--

 ^ (caret) at the end of a reference, Git resolves it to mean the parent of that commit

$ git log --pretty=format:'%h %s' --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit 'phedders/rdocs'
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list

$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

d921970^2 means “the second parent of d921970.”

--

Commit ranges
“What work is on this branch that I haven’t yet merged into my main branch?”

double-dot syntax
asks Git to resolve a range of commits that are reachable from 
one commit but aren’t reachable from another.

A < B < E < F <-master
          < C < D <- experiment

“all commits reachable from experiment that aren’t reachable from master.”

$ git log master..experiment
D
C

$ git log experiment..master
F
E

double dot is shorthand, can also use for multiple points

$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA

triple-dot syntax, which specifies all the commits that are reachable 
by either of two references but not by both of them.

$ git log master...experiment
F
E
D
C

$ git log --left-right master...experiment
< F
< E
> D
> C

Lets you see which side of the range each commit is in.

Interactive staging *************

git add -i uses an interactive shell mode

$ git add -i
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

*** Commands ***
  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked
  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp
What now>

Using option 'u' or 'update'

What now> u
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update>>

You enter 1 and 2

Update>> 1,2
           staged     unstaged path
* 1:    unchanged        +0/-1 TODO
* 2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update>>

Update>>
updated 2 paths

Now the two files are staged.

*** Commands ***
  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked
  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp
What now> s
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

If you want to unstage, you would use the 'r' option to revert.

*** Commands ***
  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked
  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp
What now> r
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert>> 1
           staged     unstaged path
* 1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert>> [enter]
reverted one path

*** Commands ***
  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked
  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp
What now> s
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

Option 6 shows the difference of the staged files.
much like specifying git diff --cached on the command line:

use 6 and review diff>> is the number of the file.

Stashing and cleaning **********************************

Stashing takes the dirty state of your working directory — that is,
 your modified tracked files and staged changes —
 and saves it on a stack of unfinished changes that you can reapply 
at any time (even on a different branch).

Example use:

You use git status.
Now you want to switch branches but you don't want to commit yet so you stash the changes.

you run:
git stash
or
git stash push

Now when you run git status it shows as up to date.

to see stashes, use git stash list

reapply by using git stash apply

or apply by name using "git stash apply stash@{2}"

git stash apply --index 
tries to reapply the staged changes.

$ git stash apply --index
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb

apply option only tries to apply the stashed work, it is still on the stack.
to drop it you can run git stash drop.

git stash --keep-index tells Git to not only include all staged content in the stash being created
but to also leave it in the index.

$ git status -s
M  index.html
 M lib/simplegit.rb

$ git stash --keep-index
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
M  index.html

stash can also stash the untracked files as well as the tracked ones

By default, git stash will stash only modified and staged tracked files.

--include-untracked or -u will include untracked files

to stash all files use -a

--patch prompts for which changes you want to stash or keep in working directory

$ git stash --patch
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 66d332e..8bb5674 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -16,6 +16,10 @@ class SimpleGit
         return `#{git_cmd} 2>&1`.chomp
       end
     end
+
+    def show(treeish = 'master')
+      command("git show #{treeish}")
+    end

 end
 test
Stash this hunk [y,n,q,a,d,/,e,?]? y

Saved working directory and index state WIP on master: 1b65b17 added the index file

Creating a branch from a stash
-----------------------

If you want an easier way to test the stashed changes again, you can run git stash branch <new branchname>, 
which creates a new branch for you with your selected branch name, checks out the commit you were on when 
you stashed your work, reapplies your work there, and then drops the stash if it applies successfully:

$ git stash branch testchanges
M	index.html
M	lib/simplegit.rb
Switched to a new branch 'testchanges'
On branch testchanges
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb

Dropped refs/stash@{0} (29d385a81d163dfd45a452a2ce816487a6b8b014)

Cleaning your Working Directory
------------------------

You may not want to stash some work or files in working directory but get rid of them.
That is what git clean is for.

git clean is designed to get rid of files in the working directory that are not tracked.

git stash --all
removes all untracked items but stores them in a stash.

$ git clean -d -n
Would remove test.o
Would remove tmp/

using -n runs a dry run
 “do a dry run and tell me what you would have removed”

git clean command will only remove untracked files that are not ignored

-x will also delete files mentioned in the gitignore file

$ git status -s
 M lib/simplegit.rb
?? build.TMP
?? tmp/

$ git clean -n -d
Would remove build.TMP
Would remove tmp/

$ git clean -n -d -x
Would remove build.TMP
Would remove test.o
Would remove tmp/

if you don't know what git clean is going to do, run it with a -n flag to get a readout of its intentions

Signing your work
---------------

 if you want to sign anything you need to get GPG configured and your personal key installed.

$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   2048R/0A46826A 2014-06-04
uid                  Scott Chacon (Git signing key) <schacon@gmail.com>
sub   2048R/874529A9 2014-06-04

read if needed..........

Solution to use if working on an open source product and want to verify the identities of the contributors

You can withold merges from individuals without keys.

Searching
--------





















































